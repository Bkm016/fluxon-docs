---
title: "变量与引用"
description: "赋值、引用运算符与作用域基础"
---

**变量** 用于为值命名并保存计算结果，**引用运算符** `&` 用于在表达式中读取变量值。本章覆盖赋值、复合赋值、
引用与作用域要点。

## 基本赋值

想复用中间结果时，可以把值赋给变量。使用 `=` 即可创建或更新变量：

```fluxon
x = 5
message = "hello"
result = 'fail'
```

要点如下：

- 不需要 `var`、`let` 等关键字，直接写 `name = expression` 即可创建或更新变量。
- 对同名变量再次赋值会覆盖先前的值，后一次赋值生效。

除了最基础的 `=` 赋值外，Fluxon 还支持常见的复合赋值运算符：

```fluxon
counter = 0
counter += 1
total *= 2
```

其语义与大多数 JVM 语言保持一致，相当于在 **原有值** 的基础上就地更新。

## 常量

Fluxon 通过 **命名约定** 识别常量：全大写标识符（模式 `[A-Z][A-Z0-9_]*`）在赋值字面量时自动成为常量。

```fluxon
PI = 3.14159        // 常量（全大写 + 字面量）
MAX_SIZE = 1024     // 常量
HTTP_200 = 200      // 常量
GREETING = "Hello"  // 常量
```

常量具有以下特性：

- **不可重新赋值**：尝试修改常量会在解析期报错
- **编译时内联**：常量引用在解析阶段被替换为字面量值，无运行时查找开销

```fluxon
PI = 3.14159
PI = 6.28        // 错误：Cannot reassign constant: PI
```

### 常量 vs 变量

只有「全大写标识符 + 字面量值」的组合才会被识别为常量：

```fluxon
// 常量
MAX = 100           // 全大写 + 字面量 → 常量
PREFIX = "log:"     // 全大写 + 字面量 → 常量

// 变量（不是常量，可重新赋值）
Max = 100           // 混合大小写 → 变量
max = 100           // 全小写 → 变量
RESULT = &x + 1     // 全大写 + 表达式 → 变量
COMPUTED = calc()   // 全大写 + 函数调用 → 变量
```

### 常量内联优化

常量在解析阶段被内联，这意味着 `&PI` 会被直接替换为 `3.14159`：

```fluxon
PI = 3.14159

def area(r) = &PI * &r * &r   // &PI 被内联为 3.14159

area(10)   // 实际执行：3.14159 * 10 * 10
```

## 引用运算符 `&`

在 Fluxon 中，始终显式区分「变量本身」和「变量里的值」。在表达式中读取变量的值时，需要在变量名前添加 `&`，
表示「取出该变量当前绑定的值」：

```fluxon
x = 10
y = &x + 5
result = &result + &i
```

使用 `&` 时需要注意：

- `&name` 可以出现在任意表达式的位置，用于取出当前作用域中对应变量的值。
- 赋值语句左侧始终写作 `name = ...`，不会出现 `&name = ...` 这样的形式。
- 在函数体或控制流结构（如循环、分支）内部使用 `&`，可以直接访问外层已存在的变量。

一个常见的出错场景是「忘记写 `&`」：

```fluxon focus={2}
name = "world"
greeting = "hello " + name   // 这里的 name 会被当作字符串字面量
// 正确写法：
greeting = "hello " + &name
```

## 作用域要点

Fluxon 的多种语法结构都会引入新的作用域：

- `for`、`when` 等控制流结构以及函数体都会形成各自的作用域。
- 在这些结构内部新建的变量，默认只在本作用域内可见。

如果希望在循环或分支内部计算得到的结果在外层同样可用，通常的写法是：

1. 在外层先声明并初始化变量。
2. 在内部作用域中，通过赋值对该变量进行累积或更新。

```fluxon
sum = 0
for i in 1..3 {
    sum += &i
}
// 退出循环后，sum 仍可在外层使用
```

如果把累加结果写成循环内部的新变量，那么外层就无法使用它：

```fluxon
for i in 1..3 {
  innerSum = &i    // innerSum 只在循环体内部可见
}
// 这里访问 innerSum 会出错，因为它超出了作用域
```

### 条件分支中的作用域

`when` 或其他分支结构体内定义的变量，默认只在对应分支中可见：

```fluxon
message = ""
when &status {
  "ok" -> {
    message = "success"      // 直接更新外层变量
  }
  "fail" -> {
    message = "failed"       // 同样更新外层变量
  }
}

// 这里可以使用更新后的 message
log = &message + "!"
```

在分支内部如果使用 `localMsg = ...` 这样的新变量名，则该变量只在当前分支块内有效，外层无法访问。

### 函数与嵌套作用域

函数体同样形成自己的作用域，函数参数和在函数内声明的变量不会泄漏到外层：

```fluxon
def add(a, b) = {
    result = &a + &b
    return &result
}

sum = add(1, 2)
// 这里看不到 result，只能看到 sum
```

在多层嵌套结构中，内层可以通过 `&` 引用外层变量，但应避免复用相同的变量名，从而遮蔽外层含义：

```fluxon
value = 10

for i in 1..2 {
    // 避免再次使用 value 作为循环内部变量名
    inner = &value + &i
}
```

如果在内层重新声明了同名变量，就会发生「变量遮蔽」（shadowing）：

```fluxon
value = 10

for i in 1..2 {
  value = 100       // 这里修改的是内层 value，而不是外层的 10
}
```

## 相关链接

- [字面量与类型](/language/literals-and-types)
- [控制流](/language/control-flow)
- [函数与异步](/language/functions-and-async)
- [术语表](/appendix/glossary)
